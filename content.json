{"meta":{"title":"京涛个人博客","subtitle":"","description":"记录 成为更好的自己","author":"京涛","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-09-30T10:00:23.000Z","updated":"2021-12-14T05:43:59.249Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-12-14T05:40:33.000Z","updated":"2021-12-14T05:44:03.951Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-12-14T05:40:33.000Z","updated":"2021-12-14T05:44:01.483Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于跨域，我想说.....","slug":"关于跨域，我想说","date":"2021-10-08T11:15:12.000Z","updated":"2021-10-11T06:09:37.575Z","comments":true,"path":"post/9ff3.html","link":"","permalink":"http://example.com/post/9ff3.html","excerpt":"","text":"什么是跨域？什么是浏览器同源政策？ 跨域：​ 浏览器可能存放用户信息，为了保护用户信息，禁止非同源请求来获取本网站的信息，为了解决同源限制所作出的行为叫做跨域。 同源政策: 两个ip地址，只有符合以下三个条件时才可以叫做同源，同源的地址之间互相访问不存在跨域问题； 1.协议相同 2.域名相同 3.端口相同 只要有一个条件不符合，就会发生跨域问题。 http://www.baidu.com/a //http:默认端口是8080https://www.baidu/com/b //https:默认端口是443A.同源 B.不同源，协议不同 C.不同源，端口不同 &#123;D.不同源，协议和端口不同&#125; 跨域方式有哪些？var xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;,&quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=%E8%BE%A3%E6%9D%A1&quot;);xhr.send();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; console.log(xhr.responseText); &#125;&#125;//这里会显示出现跨域阻止 跨域问题的第一种解决方式这里以自己搭建的淘宝和京东后台模拟为例 1.淘宝 //淘宝----------前端js代码const xhr = new XMLHttpRequest();//这里默认的请求地址是 http://localhost:8080/getInfo// xhr.open(&quot;get&quot;,&quot;/getInfo&quot;);//现在想要请求京东的资源xhr.open(&quot;get&quot;,&quot;http://localhost:9000/getInfo&quot;);xhr.send();xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4)&#123; document.querySelector(&quot;span&quot;).innerText = xhr.responseText; &#125;&#125; //淘宝----------后端js代码const express = require(&quot;express&quot;);const web = express();web.use(express.static(&quot;public&quot;));web.get(&quot;/getInfo&quot;,function (req,res)&#123; const goodList = [ &#123; name : &quot;雷神电脑&quot;, price : 9999 &#125;,&#123; name : &quot;苹果手机&quot;, price : 6999 &#125;,&#123; name : &quot;耐克球鞋&quot;, price : 999 &#125; ]; res.send(goodList);&#125;)web.listen(&quot;8080&quot;,function ()&#123; console.log(&quot;8080端口启动&quot;);&#125;) 京东 //京东----------前端js代码 和淘宝的一致//京东请求自己网站的数据，没有同源限制也就没有跨域问题const xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;,&quot;/getInfo&quot;); xhr.send(); xhr.onreadystatechange = function ()&#123; if(xhr.readyState == 4)&#123; console.log(xhr.responseText); document.querySelector(&quot;span&quot;).innerText = xhr.responseText; &#125; &#125; //京东----------后端js代码const express = require(&quot;express&quot;);const web = express();web.use(express.static(&quot;public&quot;));web.get(&quot;/getInfo&quot;,function (req,res)&#123; //-------------------------------------------------------- res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;http://localhost:8080&quot;) //-------------------------------------------------------- const bookList = [ &#123; name : &quot;海王&quot;, price : 99.99 &#125;,&#123; name : &quot;海贼王&quot;, price : 699 &#125;,&#123; name : &quot;海尔兄弟&quot;, price : 111 &#125; ]; res.send(bookList);&#125;)web.listen(&quot;9000&quot;,function ()&#123; console.log(&quot;9000端口启动&quot;);&#125;) 在这里，淘宝网站想要请求京东网站的资源时，发生了跨域请求。如果没有解决这个问题是没法请求到京东的数据的。 这里就有了第一种解决的方案，在京东的后端接口中声明， res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;希望可以被请求的地址&quot;) //这里可以写* 代表所有的不同源的网站 总结： 这里请求京东的资源会发生跨域请求,由于浏览器的同源限制，会拦截跨域请求* 控制台输出：* 已拦截跨源请求：同源策略禁止读取位于 http://localhost:9000/getInfo 的远程资源。* （原因：CORS 头缺少 &#x27;Access-Control-Allow-Origin&#x27;）。* 只需要在对应的接口中设置：* res.set(&quot;Access-Control-Allow-Origin&quot;,&quot;希望可以被请求的地址&quot;) 这里可以写* 代表所有的不同源的网站 跨域问题的第二种解决方式 问题剖析： ​ 跨域问题最根本产生的原因就是浏览器为了保护用户信息而设置了同源限制，只有同源的情况下才可以访问数据。同源限制也只是在浏览器中存在，在app等环境下运行就不会有同源限制，所以只需要想办法让请求发生不在浏览器中就可以。这里可以使用后台来请求外部资源，然后再返回给前端就可以解决跨域问题。 &lt;!-- 前端代码 --&gt;&lt;body&gt;请输入您要查询的关键字：&lt;input type=&quot;text&quot; onblur=&quot;getInfo()&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;script&gt; function getInfo() &#123; const keywords = document.querySelector(&quot;input&quot;).value; const xhr = new XMLHttpRequest(); //现在想要请求动态的资源,链接中的q参数是可变的，传入一个参数给后端 xhr.open(&quot;get&quot;, &quot;/getInfo?keyWords=&quot; + keywords); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; document.querySelector(&quot;span&quot;).innerText = xhr.responseText; &#125; &#125; &#125;&lt;/script&gt;&lt;/body&gt; const express = require(&quot;express&quot;);const web = express();web.use(express.static(&quot;public&quot;));const https = require(&quot;https&quot;)web.get(&quot;/getInfo&quot;, function (req, res) &#123; const keywords = req.query.keyWords; // 这个keywords是一个汉字字符,拼接成的url是带有中文的，需要编码 let url = &quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=&quot; + keywords; //https请求不能解析带有中文的地址 url = encodeURI(url); //在这里请求外部数据 //请求淘宝的一个搜索关键字的资源 https.get(url, function (httpsRes) &#123; let bufferData = &quot;&quot;; httpsRes.on(&quot;data&quot;, function (data) &#123; bufferData += data; &#125;); httpsRes.on(&quot;end&quot;, function () &#123; //此时bufferData是一个buffer类型的数据 bufferData = JSON.parse(bufferData); //将拼接到的资源返回给前端 res.send(bufferData); &#125;) &#125;)&#125;)web.listen(&quot;8080&quot;, function () &#123; console.log(&quot;8080端口启动&quot;);&#125;) 跨域问题的第三种解决方式 在以往的html中，也有请求外部资源的时候 比如： &lt;img src=&quot;地址&quot; alt=&quot;&quot;&gt;&lt;a href=&quot;地址&quot;&gt;&lt;/a&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;地址&quot;&gt;&lt;script src=&quot;地址&quot;&gt;&lt;/script&gt; 这些请求都可以请求成功，说明浏览器对于标签的外部资源请求是没有限制的，那么我们使用标签的形式进行请求跨域资源。 &lt;script&gt; function myCallBack(data)&#123; console.log(data); //data里面存放了&#123;result:[Array(数据)]&#125; &#125;&lt;/script&gt;&lt;script src=&quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=%E8%BE%A3%E6%9D%A1&amp;callback=myCallBack&quot;&gt;&lt;/script&gt; 在标签中进行跨域请求就不需要在接口中增加一行 res.set(“Access-Control-Allow-Origin”,”允许的对象”)也不需要通过后台的方式进行跨域请求只需要在标签中声明请求的目标资源地址就可以了，更加方便 但是这种方式也有一个问题： 怎么才能得到请求到的资源? 这里需要给请求的资源地址后面添加一个callback 回调函数 跨域问题的第四个解决方式 搭配jquery中的dataType : jsonp解决跨域问题 &lt;script src=&quot;./jQuery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $.ajax(&#123; url : &quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=%E8%BE%A3%E6%9D%A1&quot;, type : &quot;get&quot;, dataType : &quot;jsonP&quot;, success(res)&#123; console.log(res.result) &#125; &#125;)&lt;/script&gt; 跨域问题的第五个解决方式（vue）下面的例子中创建一个home.vue组件： &lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendQuest&quot;&gt;发送跨域请求&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 这里需要安装axios模块 npm install axiosimport axios from &quot;axios&quot;export default &#123; name: &quot;home&quot;, methods: &#123; sendQuest() &#123; // 这里发生了跨域请求，请求不到数据。在config/index中进行配置 // axios.get(&quot;https://suggest.taobao.com/sug?code=utf-8&amp;q=%E9%A6%99%E6%B0%B4&quot;) axios.get(&quot;/taoBao/sug?code=utf-8&amp;q=%E9%A6%99%E6%B0%B4&quot;) .then(function (data) &#123; // 请求成功 console.log(data); &#125;,function (err) &#123; // 请求错误 console.log(err); &#125;) &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;&lt;!-- 当点击按钮的时候进行数据跨域请求， --&gt; 在config/index.js/dev/proxyTable中进行配置： // proxy 代理 table 表 代理表 // vue当中使用代理表进行跨域 （反向代理）// 代理表跨域 是把url当中相同的部分截取出来proxyTable: &#123; &#x27;/taoBao&#x27;:&#123; // target目标 target:&quot;https://suggest.taobao.com&quot; , // 是否改变请求源 changeOrigin:true , // 路径重写 pathRewrite:&#123; &#x27;^/taoBao&#x27;:&quot;&quot; &#125; &#125;&#125;, 这样就可以实现vue中的跨域请求","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"前端常见面试题积累","slug":"前端常见面试题积累","date":"2021-10-05T06:36:25.000Z","updated":"2021-10-11T06:10:00.316Z","comments":true,"path":"post/f36c.html","link":"","permalink":"http://example.com/post/f36c.html","excerpt":"分享个人面试过程中常见的问题，也包含自己对问题的理解。不断完善…..","text":"分享个人面试过程中常见的问题，也包含自己对问题的理解。不断完善….. new关键字的原理当对象使用new关键字创建的时候，程序内部都做了什么？&nbsp;&nbsp;&nbsp;1.开辟内存地址，里面放置一个空的对象&nbsp;&nbsp;&nbsp;2.this指向了空的对象&nbsp;&nbsp;&nbsp;3.构造函数的参数给空的对象赋值&nbsp;&nbsp;&nbsp;4.将赋值后的对象返回给外面使用 跨域的产生原因和如何解决？关于跨域，我想要整理一篇独立的文章去解释的理解，这里直接链接到 关于跨域，我想说…..","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"filter、map、reduce的使用","slug":"filter、map、reduce的使用","date":"2021-10-04T15:20:38.000Z","updated":"2021-11-24T10:15:54.970Z","comments":true,"path":"post/4109.html","link":"","permalink":"http://example.com/post/4109.html","excerpt":"在项目开发中，会有大量的对数组、对象的操作，合理地利用部分高阶函数会让你的代码看起来更加优雅。","text":"在项目开发中，会有大量的对数组、对象的操作，合理地利用部分高阶函数会让你的代码看起来更加优雅。 直接使用一个小的案例去说明他们的关系： const nums = [10,20,111,444,40,50];// 对于数据nums现有三个需求： // 1.取出所有小于100的数字 // 2.将所有小于100的数字进行转化 --乘以2 // 3.将所有的newNums2数字相加得到最后的结果。 使用普通for循环去处理以上需求 需求1：取出所有小于100的数字 let newNums = [];for (let n of nums) &#123; if (n &lt; 100) &#123; newNums.push(n); &#125;&#125; 需求2： 将所有小于100的数字进行转化 –乘以2 let newNums2 = [];for (let n of newNums) &#123; newNums2.push(n * 2)&#125; 需求3： 将所有的newNums2数字相加得到最后的结果。 let total = 0;for (let n of newNums2) &#123; total += n;&#125; filter / map / reduce 完成以上需求//需求1：取出所有小于100的数字nums.filter(function (n) &#123; //filter中的回调函数有一个要求：必须返回一个boolean值 //当返回true时，函数内部会自动将本次回调的n加入到一个新的数组中 //当返回为false时，函数内部会过滤掉这次的n return n &lt; 100; //这里就可以直接满足第一个需求&#125;); //这里会返回一个新的数组，就是包含nums中所有值小于100的新数组let newNums = nums.filter(function (n) &#123; return n &lt; 100;&#125;)console.log(newNums); // [10,20,40,50] //需求2： 将所有小于100的数字进行转化 --乘以2let newNums2 = newNums.map(function (n) &#123; return n * 2 ;&#125;);console.log(newNums2); // [20,40,80,100] //需求3：将所有的newNums2数字相加得到最后的结果//reduce作用：对数组中所有的内容进行汇总newNums2.reduce(function (preValue , n) &#123; //preValue 是上一次返回的值 //return 100; //对应下面的过程 return preValue + n;&#125;,0)//reduce(参数1，参数2); 会返回最后汇总的结果; 参数1：整合数据操作、参数2：初始值//这里面的function会执行4次，/** 第一次： preValue-&gt;0 ; n -&gt; 20; 第二次： preValue-&gt;100 ; n -&gt;40; 第二次： preValue-&gt;100 ; n -&gt;80; 第二次： preValue-&gt;100 ; n -&gt;100;*/ 计算最终的结果 let total = nums.filter(function (n) &#123; return n &lt; 100;&#125;).map(function (n) &#123; return n * 2;&#125;).reduce(function (preValue , n) &#123; return preValue + n;&#125;,0) 这样的话就很好的简化了代码，逻辑也会更加清楚。什么？还是不够简化？那下面的代码呢？ let total = nums.filter(n =&gt; n &lt; 100).map(n =&gt; n * 2).reduce((preValue,n) =&gt; preValue + n);console.log(total); // total = 240; 总结 filter: 对数组进行过滤，当返回值为true时，才会返回当前处理的元素。 map: 映射，可以对数组中每个元素进行操作，并逐一返回，生成一个新的数组。 reduce: 接收一个函数作为累加器，数组中的每个值（从左到右）开始合并，最终返回一个值。reduce可接收的参数: reduce((参数1,参数2,参数3,参数4) =&gt; {}, 参数5)&nbsp;&nbsp;参数1. previousValue(上一次调用回调函数返回的值，或者是提供的初始值（initialValue）)&nbsp;&nbsp;参数2. currentValue(数组中当前被处理的元素)&nbsp;&nbsp;参数3. index（当前元素在数组中的索引）&nbsp;&nbsp;参数4. array（调用reduce的数组）并且reduce可以传入一个初始值（参数5），初始值的格式随意定义，如果不传，默认是previousValue","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"那些开发中的css技巧","slug":"那些开发中的css技巧","date":"2021-07-02T04:11:42.000Z","updated":"2021-11-24T10:27:23.643Z","comments":true,"path":"post/cc46.html","link":"","permalink":"http://example.com/post/cc46.html","excerpt":"在开发中合理利用css，可以大大提高开发效率","text":"在开发中合理利用css，可以大大提高开发效率 去除safari浏览器输入框的小图标以及密码输入的钥匙图标/* 去掉Safari浏览器下密码输入框自带的小钥匙图标 */input::-webkit-credentials-auto-fill-button &#123; display: none !important; visibility: hidden; pointer-events: none; position: absolute; right: 0;&#125;/* 去掉safari浏览器input右边的小图标/小按钮 */input:focus::-webkit-contacts-auto-fill-button&#123; opacity: 0;&#125; 调整浏览器滚动条的样式/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar &#123; /* width: 5px; height: 5px; */&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track &#123; border-radius: 999px; border:0px solid transparent; box-shadow: 1px 1px 5px rgba(100,100,100,.2) inset;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb &#123; border-radius: 999px;border:0px solid transparent; min-height: 20px; background-clip: content-box; box-shadow: 0 0 0 5px rgba(100,100,100,.5) inset; -webkit-box-shadow:0 0 0 5px rgba(100,100,100,.5) inset;&#125;::-webkit-scrollbar-corner &#123; background:transparent;&#125; 毛玻璃效果div &#123; background: hsla(0, 0%, 100%, .75); -webkit-backdrop-filter: blur(5px); backdrop-filter: blur(5px);&#125; 手机端点开多选框出现蓝色块* &#123; -webkit-tap-highlight-color:transparent;&#125; 鼠标放上出现一个白色的框(带动画)/* 默认样式 -- 不显示 */.border:before &#123; content: &#x27;&#x27;; position: absolute; left: 10px; top: 10px; right: 10px; bottom: 10px; box-sizing: border-box; border: 3px solid #FFFFFF; transform: scale(0); opacity: 0; transition: all .3s cubic-bezier(0.4,0,0.2,1) 0s;&#125;/* hover时改变 */.border:hover:before &#123; transform: scale(1); opacity: 1;&#125; 效果图 flex布局实现简单的瀑布流html部分 &lt;!-- 这里需要将文档结构处理成类似的结构 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;container-item&quot;&gt; &lt;img src=&quot;*&amp;^%^%&amp;%*&amp;*&quot; /&gt; &lt;h4&gt;标题1&lt;/h4&gt; &lt;p&gt;这是item1的描述信息&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container-item&quot;&gt; &lt;img src=&quot;*&amp;^%^%&amp;%*&amp;*&quot; /&gt; &lt;h4&gt;标题2&lt;/h4&gt; &lt;p&gt;这是item2的描述信息&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container-item&quot;&gt; &lt;img src=&quot;*&amp;^%^%&amp;%*&amp;*&quot; /&gt; &lt;h4&gt;标题3&lt;/h4&gt; &lt;p&gt;这是item3的描述信息&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container-item&quot;&gt; &lt;img src=&quot;*&amp;^%^%&amp;%*&amp;*&quot; /&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;p&gt;这是item4的描述信息&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css部分 .container &#123; width: 750rpx; margin: 0 auto; column-count: 4; /* 瀑布流的列数 */ column-gap: 0; /* 每列之间的间距 如： 10px;*/ &amp;-item &#123; display: flex; flex-direction: column; justify-content: center; align-items: center; &#125;&#125;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS常用工具类汇总(持续更新....)","slug":"JS常用工具类汇总(持续完善...)","date":"2021-06-29T11:41:45.000Z","updated":"2021-12-14T11:58:38.140Z","comments":true,"path":"post/535a.html","link":"","permalink":"http://example.com/post/535a.html","excerpt":"整理项目开发中经常使用的js片段","text":"整理项目开发中经常使用的js片段 创建a标签,打开新页面/** * 创建a标签,打开新页面 openURL() * @param &#123;String&#125; url 目标地址 * @returns null */function openURL(url) &#123; let aLabel = document.createElement(&#x27;a&#x27;); //设置链接 aLabel.setAttribute(&#x27;href&#x27;, url); //新窗口打开链接 aLabel.setAttribute(&#x27;target&#x27;, &#x27;_blank&#x27;); //设置标签ID aLabel.setAttribute(&#x27;id&#x27;, &#x27;reportpoint&#x27;); // 防止反复添加 if (document.getElementById(&#x27;reportpoint&#x27;)) &#123; document.body.removeChild(document.getElementById(&#x27;reportpoint&#x27;)); &#125; document.body.appendChild(aLabel); aLabel.click();&#125; 防抖函数防抖函数的原理就是通过延时器控制用户在短时间内进行重复操作的时候取消上一次操作 防抖函数/** * 防抖函数 debounce() * @param &#123;function&#125; fn 事件触发的操作 * @param &#123;number&#125; delay 多少毫秒内连续触发事件，不会执行 * @returns &#123;Function&#125; */function debounce(fn, delay) &#123; let timer = null ; return function() &#123; let self = this ; // 注意this指向 args = arguments; // 拿到函数的入参 timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(self, args); &#125;, delay) &#125;&#125;// 假设现有以下点击事件，clickEvent()let input1 = document.getElementById(&#x27;input1&#x27;);input1.addEventListener(&#x27;keyup&#x27;,debounce(action1,1000))function action1() &#123; console.log(input1.value)&#125; 节流函数节流函数的原理就是通过控制延时器,当高频事件触发，n秒内只会执行一次 节流函数/** * 节流函数 throttle() * @param &#123;function&#125; fn 事件触发的操作 * @param &#123;number&#125; delay 多少毫秒内连续触发事件，只会执行一次 * @returns &#123;Function&#125; */function throttle(fn, delay) &#123; let timer = null ; let flag = true ; // 当前是否正在执行... return function() &#123; if (!flag) return flag = false; let self = this ; // 注意this指向 args = arguments; // 拿到函数的入参 timer &amp;&amp; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; flag = true; // 时间到了，可以继续执行下一次事件 fn.apply(self, args); &#125;, delay) &#125;&#125; 使用的规则同 防抖函数 将字符串运行成js脚本的几种方式1. eval(&#x27;字符串&#x27;)2. new Function(&#x27;字符串&#x27;)3. setTimeout(&#x27;字符串&#x27;, 1000)4. setInterval(&#x27;字符串&#x27;, 1000) 浏览器复制内容到剪切板/** * 浏览器复制内容到剪切板 copyText() * @param &#123;string&#125; text 需要复制的内容 * @returns null */const copyText = (text)=&gt;&#123; var range = document.createRange(); var copyDOM = document.createElement(&#x27;a&#x27;); copyDOM.innerHTML = text; window.getSelection().removeAllRanges(); document.body.appendChild(copyDOM) range.selectNode(copyDOM); window.getSelection().addRange(range); var successful = document.execCommand(&#x27;copy&#x27;); if(successful)&#123; // 复制成功到剪切板 &#125;else&#123; // 复制失败，一般是因为浏览器不支持复制 &#125; document.body.removeChild(copyDOM)&#125; 取随机字符串取随机字符串根据业务的不同会有不一样的取值方式，用作签名的一部分、用做随机密码….这里我采用的是获取长度不定、去除容易混淆的字符oOLl,9gq,Vv,Uu,I1的随机位数的随机字符 /** * 取随机字符串 randomString() * @param &#123;number&#125; len 随机字符串的长度 * @returns null */function randomString(len) &#123; len = len || 32; // 默认随机生成32位长度字符串 var $chars = &#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27;; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var randomStr = &#x27;&#x27;; for (var i = 0; i &lt; len; i++) &#123; randomStr += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return randomStr;&#125; 异步加载一段js脚本如： 异步引入网页悬浮脚本、异步引入高德地图、腾讯地图等。 /** * @description 异步加载 一段js放在 header * @param &#123;object&#125; url - js 的 url * @param &#123;function&#125; callback - 成功回调 * @returns &#123; promise&lt;any&gt;&#125;&#125; promise */const loadScript = (url: string) =&gt; &#123; return new Promise(() =&gt; &#123; try &#123; const script: any = document.createElement(&#x27;script&#x27;) script.type = &#x27;text/javascript&#x27; if (script.readyState) &#123; //IE script.onreadystatechange = function () &#123; if ( script.readyState == &#x27;loaded&#x27; || script.readyState == &#x27;complete&#x27; ) &#123; script.onreadystatechange = null Promise.resolve(0) &#125; &#125; &#125; else &#123; //Others: Firefox, Safari, Chrome, and Opera script.onload = function () &#123; Promise.resolve(0) &#125; &#125; script.src = url document.body.appendChild(script) &#125; catch (e) &#123; Promise.reject(e) &#125; &#125;)&#125; 获取页面高度// get page heightconst getPageHeight = () =&gt; &#123; const g = document const a = g.body const f = g.documentElement const d = g.compatMode === &#x27;BackCompat&#x27; ? a : g.documentElement return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight)&#125; 获取页面可视高度// get page view heightconst getPageViewHeight = () =&gt; &#123; const d = document const a = d.compatMode === &#x27;BackCompat&#x27; ? d.body : d.documentElement return a.clientHeight&#125; 获取页面可视宽度// get page view widthconst getPageViewWidth = () =&gt; &#123; const d = document const a = d.compatMode === &#x27;BackCompat&#x27; ? d.body : d.documentElement return a.clientWidth&#125; 获取页面宽度// get page widthconst getPageWidth = () =&gt; &#123; const g = document const a = g.body const f = g.documentElement const d = g.compatMode === &#x27;BackCompat&#x27; ? a : g.documentElement return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth)&#125; 判断当前设备是否为安卓设备const isAndroidMobileDevice = () =&gt; &#123; return /android/i.test(navigator.userAgent.toLowerCase())&#125; 是否为苹果设备const isAppleMobileDevice = () =&gt; &#123; return /iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase())&#125; 是否为iPhoneXconst isIphonex = () =&gt; &#123; // X XS, XS Max, XR const xSeriesConfig = [ &#123; devicePixelRatio: 3, width: 375, height: 812 &#125;, &#123; devicePixelRatio: 3, width: 414, height: 896 &#125;, &#123; devicePixelRatio: 2, width: 414, height: 896 &#125; ] if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window) &#123; const isIOS = /iphone/gi.test(window.navigator.userAgent) if (!isIOS) return false const &#123; devicePixelRatio, screen &#125; = window const &#123; width, height &#125; = screen return xSeriesConfig.some( (item) =&gt; item.devicePixelRatio === devicePixelRatio &amp;&amp; item.width === width &amp;&amp; item.height === height ) &#125; return false&#125; 是否为手机设备const isMobileUserAgent = () =&gt; &#123; return /iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test( window.navigator.userAgent.toLowerCase() )&#125; 设置cookie/** * @description 设置 cookie * @params &#123;string&#125; cookie -键名 * @params &#123;any&#125; value -存入的值 * @params &#123;Hours&#125; number -有效期限 */const setCookie = (name: string, value: any, Hours: number) =&gt; &#123; const d = new Date() const offset = 8 const utc = d.getTime() + d.getTimezoneOffset() * 60000 const nd = utc + 3600000 * offset const exp = new Date(nd) exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000) document.cookie = name + &#x27;=&#x27; + escape(value) + &#x27;;path=/;expires=&#x27; + exp.toUTCString() + &#x27;;domain=360doc.com;&#x27;&#125; 获取字符串对应的字节数/** * @description 获取字节数 * @param s 字符串 */const getBytesLength = (s: string) =&gt; &#123; return s.replace(/[^\\x00-\\xff]/gi, &#x27;--&#x27;).length&#125; 获取本地的时间/** * 获取本地的时间 */const getServerTime = () =&gt; &#123; var xmlHttp: XMLHttpRequest function srvTime() &#123; try &#123; // FF, Opera, Safari, Chrome xmlHttp = new XMLHttpRequest() &#125; catch (err1) &#123; // IE try &#123; xmlHttp = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;) &#125; catch (err2) &#123; try &#123; xmlHttp = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;) &#125; catch (eerr3) &#123; // AJAX not supported, use CPU time. alert(&#x27;AJAX not supported&#x27;) &#125; &#125; &#125; xmlHttp.open(&#x27;HEAD&#x27;, window.location.href.toString(), false) xmlHttp.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;) xmlHttp.send(&#x27;&#x27;) return xmlHttp.getResponseHeader(&#x27;Date&#x27;) &#125; var st = srvTime() var date = new Date(st as string) var timestamp = date.getTime() return timestamp&#125; 获取浏览器的Cookie的值/** * 获取浏览器的Cookie的值 */const cookie = name =&gt; `; $&#123;document.cookie&#125;`.split(`; $&#123;name&#125;=`).pop().split(&#x27;;&#x27;).shift();// 获取token cookie(&#x27;TOKEN&#x27;) 颜色RGB转十六进制/** * 颜色RGB转十六进制 */const rgbToHex = (r, g, b) =&gt; &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);rgbToHex(0, 51, 255); // Result: #0033ff 复制到剪贴板(新的API)/** * 复制到剪贴板 */const copyToClipboard = (text) =&gt; navigator.clipboard.writeText(text); copyToClipboard(&quot;Hello World&quot;); 清除所有Cookie/** * 清除所有Cookie */const clearCookies = document.cookie.split(&#x27;;&#x27;).forEach(cookie =&gt; document.cookie = cookie.replace(/^ +/, &#x27;&#x27;).replace(/=.*/, `=;expires=$&#123;new Date(0).toUTCString()&#125;;path=/`)); 生成随机十六进制颜色/** * 生成随机十六进制颜色 */const randomHex = () =&gt; `#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;)&#125;`; console.log(randomHex());// Result: #92b008 从URL获取查询参数 – JS/** * 从URL获取查询参数 */const getParameters = (URL) =&gt; &#123; URL = JSON.parse( &#x27;&#123;&quot;&#x27; + decodeURI(URL.split(&quot;?&quot;)[1]) .replace(/&quot;/g, &#x27;\\\\&quot;&#x27;) .replace(/&amp;/g, &#x27;&quot;,&quot;&#x27;) .replace(/=/g, &#x27;&quot;:&quot;&#x27;) + &#x27;&quot;&#125;&#x27; ); return JSON.stringify(URL);&#125;;// 调用getParameters(window.location);// Result: &#123; search : &quot;easy&quot;, page : 3 &#125; 或者： /** * 从URL获取查询参数 */Object.fromEntries(new URLSearchParams(window.location.search)) 检查用户的设备是否在暗黑模式/** * 检查用户的设备是否在暗黑模式 * @return Boolean */const isDarkMode = window.matchMedia &amp;&amp; window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;).matches 下载一个Excel文档/** * 下载一个链接 */ function download(link, name) &#123; if(!name)&#123; name = link.slice(link.lastIndexOf(&#x27;/&#x27;) + 1) &#125; let eleLink = document.createElement(&#x27;a&#x27;) eleLink.download = name eleLink.style.display = &#x27;none&#x27; eleLink.href = link document.body.appendChild(eleLink) eleLink.click() document.body.removeChild(eleLink)&#125;//下载exceldownload(&#x27;http://111.229.14.189/file/1.xlsx&#x27;) 浏览器中下载一些DOM内容/JSON文件/** * 浏览器下载静态文件 * @param &#123;String&#125; name 文件名 * @param &#123;String&#125; content 文件内容 */function downloadFile(name, content) &#123; if (typeof name == &#x27;undefined&#x27;) &#123; throw new Error(&#x27;The first parameter name is a must&#x27;) &#125; if (typeof content == &#x27;undefined&#x27;) &#123; throw new Error(&#x27;The second parameter content is a must&#x27;) &#125; if (!(content instanceof Blob)) &#123; content = new Blob([content]) &#125; const link = URL.createObjectURL(content) download(link, name)&#125;// 调用下载downloadFile(&#x27;1.txt&#x27;,&#x27;lalalallalalla&#x27;)downloadFile(&#x27;1.json&#x27;,JSON.stringify(&#123;name:&#x27;hahahha&#x27;&#125;)) 浏览器下载MP4/PDF/图片等/** * 浏览器下载MP4/PDF/图片等 */import axios from &#x27;axios&#x27;//提供一个link，完成文件下载，link可以是 http://xxx.com/xxx.xlsfunction downloadByLink(link,fileName)&#123; axios.request(&#123; url: link, responseType: &#x27;blob&#x27; // 关键代码，让axios把响应改成blob &#125;).then(res =&gt; &#123; const link = URL.createObjectURL(res.data) download(link, fileName) &#125;)&#125; 注意：会有同源策略的限制，需要配置转发 去除对象中的空元素给后端发送数据的时候，要判断某个属性是不是空字符串，然后给后端拼参数，这块逻辑抽离出来就是cleanObject，代码实现如下： /** * cleanObject 去除对象中的空元素 */export const cleanObject = (object) =&gt; &#123; // Object.assign(&#123;&#125;, object) if (!object) &#123; return &#123;&#125;; &#125; const result = &#123; ...object &#125;; Object.keys(result).forEach((key) =&gt; &#123; const value = result[key]; if (isVoid(value)) &#123; delete result[key]; &#125; &#125;); return result;&#125;;// 判断是否为空export const isVoid = (value) =&gt; value === undefined || value === null || value === &quot;&quot;; 使用： let res = cleanObject(&#123; name:&#x27;&#x27;, pageSize:10, page:1&#125;)console.log(&quot;res&quot;, res) // 输出 &#123; page:1,pageSize:10 &#125; 常用的正则验证/** * 常用的正则验证 */const checkStr = function(str, type) &#123; // 常用正则验证，注意type大小写 switch (type) &#123; case &#x27;phone&#x27;: // 手机号码 return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str) case &#x27;tel&#x27;: // 座机 return /^(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)(-\\d&#123;1,4&#125;)?$/.test(str) case &#x27;card&#x27;: // 身份证 return /(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)/.test(str) case &#x27;pwd&#x27;: // 密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\\w&#123;5,17&#125;$/.test(str) case &#x27;postal&#x27;: // 邮政编码 return /[1-9]\\d&#123;5&#125;(?!\\d)/.test(str) case &#x27;QQ&#x27;: // QQ号 return /^[1-9][0-9]&#123;4,9&#125;$/.test(str) case &#x27;email&#x27;: // 邮箱 return /^[\\w-]+(.[\\w-]+)*@[\\w-]+(.[\\w-]+)+$/.test(str) case &#x27;money&#x27;: // 金额(小数点2位) return /^\\d*(?:.\\d&#123;0,2&#125;)?$/.test(str) case &#x27;URL&#x27;: // 网址 return /(http|ftp|https)://[\\w-_]+(.[\\w-_]+)+([\\w-.,@?^=%&amp;:/~+#]*[\\w-@?^=%&amp;/~+#])?/.test(str) case &#x27;IP&#x27;: // IP return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str) case &#x27;date&#x27;: // 日期时间 return /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;) (\\d&#123;2&#125;)(?::\\d&#123;2&#125;|:(\\d&#123;2&#125;):(\\d&#123;2&#125;))$/.test(str) || /^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)$/.test(str) case &#x27;number&#x27;: // 数字 return /^[0-9]$/.test(str) case &#x27;english&#x27;: // 英文 return /^[a-zA-Z]+$/.test(str) case &#x27;chinese&#x27;: // 中文 return /^[\\u4E00-\\u9FA5]+$/.test(str) case &#x27;lower&#x27;: // 小写 return /^[a-z]+$/.test(str) case &#x27;upper&#x27;: // 大写 return /^[A-Z]+$/.test(str) case &#x27;HTML&#x27;: // HTML标记 return /&lt;(&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*&gt;/.test(str) default: return true &#125;&#125; 阿拉伯数字转中文大写数字/** * 阿拉伯数字转中文大写数字 */const numberToChinese = function(num) &#123; // 将阿拉伯数字翻译成中文的大写数字 let AA = new Array(&#x27;零&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;, &#x27;七&#x27;, &#x27;八&#x27;, &#x27;九&#x27;, &#x27;十&#x27;) let BB = new Array(&#x27;&#x27;, &#x27;十&#x27;, &#x27;百&#x27;, &#x27;仟&#x27;, &#x27;萬&#x27;, &#x27;億&#x27;, &#x27;点&#x27;, &#x27;&#x27;) let a = (&#x27;&#x27; + num).replace(/(^0*)/g, &#x27;&#x27;).split(&#x27;.&#x27;) let k = 0 let re = &#x27;&#x27; for (let i = a[0].length - 1; i &gt;= 0; i--) &#123; switch (k) &#123; case 0: re = BB[7] + re break case 4: if (!new RegExp(&#x27;0&#123;4&#125;//d&#123;&#x27; + (a[0].length - i - 1) + &#x27;&#125;$&#x27;).test(a[0])) &#123; re = BB[4] + re &#125; break case 8: re = BB[5] + re BB[7] = BB[5] k = 0 break &#125; if (k % 4 === 2 &amp;&amp; a[0].charAt(i + 2) !== 0 &amp;&amp; a[0].charAt(i + 1) === 0) &#123; re = AA[0] + re &#125; if (a[0].charAt(i) !== 0) &#123; re = AA[a[0].charAt(i)] + BB[k % 4] + re &#125; k++ &#125; if (a.length &gt; 1) &#123; // 加上小数部分(如果有小数部分) re += BB[6] for (let i = 0; i &lt; a[1].length; i++) &#123; re += AA[a[1].charAt(i)] &#125; &#125; if (re === &#x27;一十&#x27;) &#123; re = &#x27;十&#x27; &#125; if (re.match(/^一/) &amp;&amp; re.length === 3) &#123; re = re.replace(&#x27;一&#x27;, &#x27;&#x27;) &#125; return re&#125; base64图片下载功能/** * base64图片下载功能 */const downloadFile = function(base64, fileName) &#123; //base64图片下载功能 let base64ToBlob = function(code) &#123; let parts = code.split(&#x27;;base64,&#x27;); let contentType = parts[0].split(&#x27;:&#x27;)[1]; let raw = window.atob(parts[1]); let rawLength = raw.length; let uInt8Array = new Uint8Array(rawLength); for (let i = 0; i &lt; rawLength; ++i) &#123; uInt8Array[i] = raw.charCodeAt(i); &#125; return new Blob([uInt8Array], &#123; type: contentType &#125;); &#125;; let aLink = document.createElement(&#x27;a&#x27;); let blob = base64ToBlob(base64); //new Blob([content]); let evt = document.createEvent(&quot;HTMLEvents&quot;); evt.initEvent(&quot;click&quot;, true, true); //initEvent不加后两个参数在FF下会报错 事件类型，是否冒泡，是否阻止浏览器的默认行为 aLink.download = fileName; aLink.href = URL.createObjectURL(blob); aLink.click();&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"}]},{"title":"hexo + volantis 搭建个人博客?","slug":"如何搭建个人博客","date":"2021-06-25T05:36:46.000Z","updated":"2021-10-08T09:54:07.071Z","comments":true,"path":"post/9487.html","link":"","permalink":"http://example.com/post/9487.html","excerpt":"使用hexo搭建个人博客","text":"使用hexo搭建个人博客 搭建博客的框架很多，个人比较偏向于hexo框架： hexo只需要专注于写文档而不需要过分担心别的问题。 hexo比较成熟，如果遇到问题也可以得到很好的解决。 hexo使用github pages进行部署，不需要购买自己的服务器就可以部署到线上。 hexo有很好的主题，如：volantis， yilia…. hexo中文网站 volantis主题官方文档 1. 搭建hexo环境 hexo是基于node开发的，首先需要安装node ，其次如果想要部署到github pages 需要安装git 安装淘宝镜像sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo-clisudo cnpm install -g hexo-cli 检查是否安装成功hexo -v 2. 创建hexo项目首先创建一个空的文件夹用于存放hexo项目代码，并在创建的目录中打开终端 mkdir &lt;floder&gt;cd &lt;floder&gt;hexo init// 或者直接借助hexo去实现hexo init &lt;floder&gt; // 这里hexo会自动创建文件夹并初始化项目 安装依赖 npm install 3. 启动项目启动项目常用的命令 hexo clean // 清除项目中的临时文件hexo g // OR hexo generate 生成临时文件hexo s // OR hexo start 启动项目 此时页面可以看到一个默认的博客模板并且有一篇默认的hello world 文章 4. 新建一篇文章hexo new &quot;如何搭建个人博客&quot; 5. 切换自己喜欢的主题这里以Volantis主题为例，具体的主题需要参照具体的官方文档来做 下载主题插件 npm i hexo-theme-volantis 修改_config.yml中的 theme 字段为volantis theme: volantis 安装 Hexo 搜索的依赖包 npm i hexo-generator-search hexo-generator-json-content 安装 Stylus 渲染器 npm i hexo-renderer-stylus 这样就可以看到精美的主题啦，之后的细节慢慢去调试成自己喜欢的样子（参考对应的官方文档） 6. 部署到github pages第一步： 在github上新建一个仓库，仓库的名字为：&lt;用户名&gt;.github.io （必须） 第二步： 修改项目根目录下的_config.yml中的 deploy 字段为： deploy: type: git repo: // 这里修改成自己的github仓库地址 branch: master 第三步： 将代码部署到github pages hexo cleanhexo g // OR hexo generatehexo d // OR hexo deploy 此时控制台会报错：ERROR Deployer not found: git这是因为项目缺少git部署的插件 npm install --save hexo-deployer-git 执行以上的语句即可～～～～～～～然后重复第三步此时就可以看到git仓库中已经有了一部分代码,神奇的是：此时去访问：&lt;用户名&gt;.github.io 就可以看到线上的博客样式了。 github pages demo, JingTao-Li.github.io, 7. 修改github page 为自定义的域名点击解析，添加对应的IP地址和CNAME然后在当前项目的 source/ 目录下创建一个名叫 CNAME 的文件，里面的内容就是你的域名地址。接着重新部署一下就可以了。 8. 如何在项目中引入本地图片第一步：安装插件： npm install hexo-asset-image --save 第二步：打开根目录下的 _config.yml 文件，修改 post_asset_folder 字段为 true 第三步：打开 /node_modules/hexo-asset-image/index.js 文件，替换为以下代码： &#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 第四步：之后在新建一个新的文档内容的时候会自动生成一个同名文件夹，里面就可以放本页面需要的图片源文件，在需要的地方引入： ![这是代替图片的文字，随便写](图片名字)","categories":[{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"搭建","slug":"搭建","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-22T11:41:45.000Z","updated":"2021-09-30T08:26:11.847Z","comments":true,"path":"post/3eeb.html","link":"","permalink":"http://example.com/post/3eeb.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://example.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"JS","slug":"JS","permalink":"http://example.com/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"搭建","slug":"搭建","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA/"}]}